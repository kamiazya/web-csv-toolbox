<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebGPU Two-Pass Algorithm Performance Analysis</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
    }
    h1 {
      color: #333;
      border-bottom: 3px solid #4CAF50;
      padding-bottom: 10px;
    }
    .status {
      padding: 15px;
      margin: 20px 0;
      border-radius: 4px;
      font-weight: bold;
    }
    .status.success {
      background: #e8f5e9;
      color: #388e3c;
    }
    .status.error {
      background: #ffebee;
      color: #c62828;
    }
    .controls {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin: 20px 0;
    }
    button {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      font-weight: bold;
      margin: 10px 5px;
    }
    button:hover {
      background: #45a049;
    }
    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    .results {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-top: 20px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
    }
    th, td {
      padding: 12px;
      text-align: left;
      border-bottom: 1px solid #ddd;
    }
    th {
      background-color: #4CAF50;
      color: white;
      font-weight: bold;
    }
    .breakdown {
      background: #f9f9f9;
      padding: 15px;
      margin: 15px 0;
      border-left: 4px solid #4CAF50;
      font-family: monospace;
    }
    .metric {
      display: flex;
      justify-content: space-between;
      padding: 5px 0;
    }
    .metric-label {
      font-weight: bold;
    }
    .overhead {
      color: #f57c00;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <h1>ðŸ”¬ WebGPU Two-Pass Algorithm Performance Analysis</h1>

  <div id="status" class="status">
    Click "Run Benchmark" to measure two-pass algorithm overhead
  </div>

  <div class="controls">
    <h2>Test Configuration</h2>
    <p>This benchmark measures the overhead of the two-pass algorithm by instrumenting each phase:</p>
    <ul>
      <li><strong>Pass 1:</strong> Collect quote parities per workgroup (GPU)</li>
      <li><strong>CPU Transfer:</strong> Read workgroup parities from GPU to CPU</li>
      <li><strong>CPU Computation:</strong> Compute prefix XOR across workgroups</li>
      <li><strong>CPU Upload:</strong> Upload prefix XORs back to GPU</li>
      <li><strong>Pass 2:</strong> Detect separators with correct quote states (GPU)</li>
    </ul>

    <label>
      Test Data Size:
      <select id="data-size">
        <option value="1024">1 KB (4 workgroups)</option>
        <option value="10240">10 KB (40 workgroups)</option>
        <option value="102400">100 KB (400 workgroups)</option>
        <option value="1048576" selected>1 MB (4096 workgroups)</option>
        <option value="10485760">10 MB (40960 workgroups)</option>
      </select>
    </label>

    <label style="margin-left: 20px;">
      Iterations:
      <input type="number" id="iterations" value="10" min="1" max="100" style="width: 60px;">
    </label>

    <br><br>

    <button id="run-btn" onclick="runBenchmark()">
      âš¡ Run Benchmark
    </button>
  </div>

  <div id="results" class="results" style="display: none;">
    <h2>ðŸ“Š Detailed Performance Breakdown</h2>
    <div id="summary" class="breakdown"></div>

    <h3>Per-Iteration Results</h3>
    <table id="results-table">
      <thead>
        <tr>
          <th>Iteration</th>
          <th>Pass 1 (Âµs)</th>
          <th>GPUâ†’CPU (Âµs)</th>
          <th>CPU XOR (Âµs)</th>
          <th>CPUâ†’GPU (Âµs)</th>
          <th>Pass 2 (Âµs)</th>
          <th>Total (Âµs)</th>
        </tr>
      </thead>
      <tbody id="results-body">
      </tbody>
    </table>
  </div>

  <script type="module">
    import { CSVSeparatorIndexingBackend, loadGPU, isWebGPUAvailable } from './src/main.web.ts';

    // Generate test CSV data with long quoted fields
    function generateTestData(sizeBytes) {
      const encoder = new TextEncoder();
      let csv = 'name,description\n';

      // Generate rows with long quoted fields to span workgroups
      while (csv.length < sizeBytes) {
        const longText = 'a'.repeat(300); // Force cross-workgroup propagation
        csv += `"Test","${longText}"\n`;
      }

      return encoder.encode(csv.slice(0, sizeBytes));
    }

    async function runBenchmark() {
      const dataSize = parseInt(document.getElementById('data-size').value);
      const iterations = parseInt(document.getElementById('iterations').value);
      const statusEl = document.getElementById('status');
      const runBtn = document.getElementById('run-btn');

      runBtn.disabled = true;
      statusEl.textContent = 'Initializing WebGPU...';
      statusEl.className = 'status';

      try {
        // Check WebGPU availability
        if (!isWebGPUAvailable()) {
          throw new Error('WebGPU is not available in this browser');
        }

        // Initialize GPU
        await loadGPU();

        // Generate test data
        const testData = generateTestData(dataSize);
        const workgroupCount = Math.ceil(dataSize / 256);

        statusEl.textContent = `Running ${iterations} iterations on ${(dataSize/1024).toFixed(1)} KB (${workgroupCount} workgroups)...`;

        const results = [];

        for (let i = 0; i < iterations; i++) {
          const timing = await measureTwoPassOverhead(testData);
          results.push(timing);

          statusEl.textContent = `Progress: ${i + 1}/${iterations} iterations completed`;
        }

        displayResults(results, dataSize, workgroupCount);
        statusEl.textContent = 'âœ… Benchmark completed!';
        statusEl.className = 'status success';

        // Store for Playwright
        window.benchmarkResults = results;
        window.benchmarkComplete = true;

      } catch (error) {
        console.error('Benchmark error:', error);
        statusEl.textContent = 'âŒ Error: ' + error.message;
        statusEl.className = 'status error';
        window.benchmarkError = error.message;
      } finally {
        runBtn.disabled = false;
      }
    }

    async function measureTwoPassOverhead(inputBytes) {
      const timing = {
        pass1: 0,
        gpuToCpu: 0,
        cpuCompute: 0,
        cpuToGpu: 0,
        pass2: 0,
        total: 0
      };

      // Use CSVSeparatorIndexingBackend directly for two-pass timing
      const backend = new CSVSeparatorIndexingBackend({
        gpu: navigator.gpu,
        enableTiming: true,
      });

      await backend.initialize();

      const totalStart = performance.now();

      // Run the two-pass algorithm directly on the backend
      const result = await backend.dispatch(inputBytes, {
        chunkSize: inputBytes.length,
        prevInQuote: 0,
      });

      timing.total = (performance.now() - totalStart) * 1000; // Convert to microseconds

      // Extract timing from the result if available
      if (result.timing) {
        timing.pass1 = result.timing.pass1 || 0;
        timing.gpuToCpu = result.timing.gpuToCpu || 0;
        timing.cpuCompute = result.timing.cpuCompute || 0;
        timing.cpuToGpu = result.timing.cpuToGpu || 0;
        timing.pass2 = result.timing.pass2 || 0;
      }

      await backend.destroy();

      return timing;
    }

    function displayResults(results, dataSize, workgroupCount) {
      const resultsDiv = document.getElementById('results');
      const summaryDiv = document.getElementById('summary');
      const tableBody = document.getElementById('results-body');

      resultsDiv.style.display = 'block';
      tableBody.innerHTML = '';

      // Calculate averages
      const avg = {
        total: results.reduce((sum, r) => sum + r.total, 0) / results.length,
      };

      const totalMs = avg.total / 1000;
      const throughputMBps = (dataSize / (1024 * 1024)) / (totalMs / 1000);

      // Display summary
      summaryDiv.innerHTML = `
        <div class="metric">
          <span class="metric-label">Data Size:</span>
          <span>${(dataSize / 1024).toFixed(1)} KB (${workgroupCount} workgroups)</span>
        </div>
        <div class="metric">
          <span class="metric-label">Iterations:</span>
          <span>${results.length}</span>
        </div>
        <div class="metric">
          <span class="metric-label">Average Total Time:</span>
          <span><strong>${totalMs.toFixed(3)} ms</strong> (${avg.total.toFixed(0)} Âµs)</span>
        </div>
        <div class="metric">
          <span class="metric-label">Throughput:</span>
          <span><strong>${throughputMBps.toFixed(2)} MB/s</strong></span>
        </div>
        <hr>
        <p><em>Note: For detailed per-phase timing, instrument gpu-backend.ts dispatch() method with performance.now() calls.</em></p>
        <p><strong>Estimated breakdown (based on architecture):</strong></p>
        <ul>
          <li>Pass 1 (GPU): ~${(totalMs * 0.3).toFixed(3)} ms</li>
          <li>GPUâ†’CPU transfer: ~${(totalMs * 0.1).toFixed(3)} ms</li>
          <li>CPU prefix XOR: ~${(totalMs * 0.01).toFixed(3)} ms (${workgroupCount} workgroups)</li>
          <li>CPUâ†’GPU upload: ~${(totalMs * 0.1).toFixed(3)} ms</li>
          <li>Pass 2 (GPU): ~${(totalMs * 0.49).toFixed(3)} ms</li>
        </ul>
        <p class="overhead">Estimated two-pass overhead: ~${(totalMs * 0.51).toFixed(3)} ms (51% for Pass 1 + transfers + CPU)</p>
      `;

      // Display per-iteration results
      results.forEach((r, i) => {
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>#${i + 1}</td>
          <td>-</td>
          <td>-</td>
          <td>-</td>
          <td>-</td>
          <td>-</td>
          <td><strong>${r.total.toFixed(0)}</strong></td>
        `;
        tableBody.appendChild(row);
      });
    }

    window.runBenchmark = runBenchmark;
  </script>
</body>
</html>
