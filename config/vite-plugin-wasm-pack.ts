// Copy from https://github.com/nshen/vite-plugin-wasm-pack/blob/a6d261f55a0ef53eb4c277251c5d7391ee657bae/src/index.ts
// and edit for some improvements.
import { readFileSync, createReadStream } from "fs";
import fs from "fs/promises";
import path from "path";
import { PluginOption } from "vite";

async function exists(filepath: string) {
  try {
    return !!(await fs.lstat(filepath));
  } catch (e) {
    return false;
  }
}
/**
 *   return a Vite plugin for handling wasm-pack crate
 *
 *   only use local crate
 *
 *   import wasmPack from 'vite-plugin-wasm-pack';
 *
 *   plugins: [wasmPack(['./my-local-crate'])]
 *
 *   only use npm crate, leave the first param to an empty array
 *
 *   plugins: [wasmPack([],['test-npm-crate'])]
 *
 *   use both local and npm crate
 *
 *   plugins: [wasmPack(['./my-local-crate'],['test-npm-crate'])]
 *
 * @param crates local crates paths, if you only use crates from npm, leave an empty array here.
 * @param moduleCrates crates names from npm
 */
function vitePluginWasmPack(crates: string[] | string): PluginOption {
  const prefix = "@vite-plugin-wasm-pack@";
  const pkg = "pkg"; // default folder of wasm-pack module
  let config_base: string;
  let config_assetsDir: string;
  const cratePaths: string[] = typeof crates === "string" ? [crates] : crates;

  // from ../../my-crate  ->  my_crate_bg.wasm
  const wasmFilename = (cratePath: string) => {
    return path.basename(cratePath).replace(/\-/g, "_") + "_bg.wasm";
  };
  type CrateType = { path: string };
  // wasmfileName : CrateType
  const wasmMap = new Map<string, CrateType>();
  // 'my_crate_bg.wasm': {path:'../../my_crate/pkg/my_crate_bg.wasm'}
  cratePaths.forEach((cratePath) => {
    const wasmFile = wasmFilename(cratePath);
    wasmMap.set(wasmFile, {
      path: path.join(cratePath, pkg, wasmFile),
    });
  });

  return {
    name: "vite-plugin-wasm-pack",
    enforce: "pre",
    configResolved(resolvedConfig) {
      config_base = resolvedConfig.base;
      config_assetsDir = resolvedConfig.build.assetsDir;
    },

    resolveId(id: string) {
      for (let i = 0; i < cratePaths.length; i++) {
        if (path.basename(cratePaths[i]) === id) return prefix + id;
      }
      return null;
    },

    async load(id: string) {
      if (id.indexOf(prefix) === 0) {
        id = id.replace(prefix, "");
        const modulejs = path.join(
          "./node_modules",
          id,
          id.replace(/\-/g, "_") + ".js",
        );
        const code = await fs.readFile(modulejs, {
          encoding: "utf-8",
        });
        return code;
      }
    },

    async buildStart(_inputOptions) {
      const prepareBuild = async (cratePath: string) => {
        const pkgPath = path.join(cratePath, pkg);
        const crateName = path.basename(cratePath);
        if ((await exists(pkgPath)) === false) {
          console.error(
            `Error: Can't find ${pkgPath}, run wasm-pack build ${cratePath} --target web first`,
          );
        }
        // copy pkg generated by wasm-pack to node_modules
        try {
          await fs.cp(pkgPath, path.join("node_modules", crateName), {
            recursive: true,
          });
        } catch (error) {
          this.error(`copy crates failed: ${error}`);
        }
        // replace default load path with '/assets/xxx.wasm'
        const jsName = crateName.replace(/\-/g, "_") + ".js";

        /**
         * if use node module and name is '@group/test'
         * cratePath === '@group/test'
         * crateName === 'test'
         */

        let jsPath = path.join("./node_modules", crateName, jsName);
        const regex = /input = new URL\('(.+)'.+;/g;
        let code = await fs.readFile(path.resolve(jsPath), {
          encoding: "utf-8",
        });
        code = code.replace(regex, (_match, group1) => {
          return `input = "${path.posix.join(
            config_base,
            config_assetsDir,
            group1,
          )}"`;
        });
        await fs.writeFile(jsPath, code);
      };

      for await (const cratePath of cratePaths) {
        await prepareBuild(cratePath);
      }
    },

    configureServer(server) {
      server.middlewares.use((req, res, next) => {
        if (req.url && /\.wasm?$/.test(req.url)) {
          const basename = path.basename(req.url);
          const entry = wasmMap.get(basename);
          if (entry) {
            res
              .setHeader("Content-Type", "application/wasm")
              .setHeader(
                "Cache-Control",
                "no-cache, no-store, must-revalidate",
              );
            createReadStream(entry!.path).pipe(res);
            return;
          }
        }
        next();
      });
      // return () => {
      //   // send 'root/pkg/xxx.wasm' file to user
      //   // server.middlewares.use((req, res, next) => {
      //   //   // console.log("req.url", req.url);
      //   //   // if (typeof req.url === "string") {
      //   //   //   const basename = path.basename(req.url);
      //   //   //   res.setHeader(
      //   //   //     "Cache-Control",
      //   //   //     "no-cache, no-store, must-revalidate",
      //   //   //   );
      //   //   //   const entry = wasmMap.get(basename);
      //   //   //   console.log("entry", basename);
      //   //   //   if (basename.endsWith(".wasm") && entry) {
      //   //   //     res.writeHead(200, { "Content-Type": "application/wasm" });
      //   //   //     createReadStream(entry.path).pipe(res);
      //   //   //   } else {
      //   //   //     next();
      //   //   //   }
      //   //   // }

      //   // });
      // };
    },

    buildEnd() {
      // copy xxx.wasm files to /assets/xxx.wasm
      wasmMap.forEach((crate, fileName) => {
        this.emitFile({
          type: "asset",
          fileName: `assets/${fileName}`,
          source: readFileSync(crate.path),
        });
      });
    },
  };
}

export default vitePluginWasmPack;
