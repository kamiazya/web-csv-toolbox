const e="../../parser/api/string/parseStringToArraySyncWASM.slim.ts",t=async(e,t,r)=>{try{for await(const i of r){const r={id:t,type:"record",record:i};e.postMessage(r)}const o={id:t,type:"done"};e.postMessage(o)}catch(o){const r={id:t,type:"error",error:o instanceof Error?o.message:String(o)};e.postMessage(r)}},r=async(e,t)=>{try{for await(const r of t)e.postMessage({type:"record",record:r});e.postMessage({type:"done"})}catch(r){e.postMessage({type:"error",error:r instanceof Error?r.message:String(r)})}};"undefined"!=typeof globalThis&&(globalThis.__vitest_browser_runner__||(globalThis.__vitest_browser_runner__={wrapDynamicImport:e=>e()}));const o=self,i=(o=>async i=>{const{id:s,type:n,useWASM:a,resultPort:h}=i;try{if(h){if("parseStringStream"===n){const e=i,t=e.stream||e.data;if(!t)throw new Error("parseStringStream with resultPort requires 'stream' or 'data' property, but both were undefined. Available properties: "+Object.keys(e).join(", "));const{FlexibleStringCSVLexer:o}=await Promise.resolve().then(()=>b),{createCSVRecordAssembler:s}=await Promise.resolve().then(()=>x),{CSVLexerTransformer:n}=await Promise.resolve().then(()=>N),{CSVRecordAssemblerTransformer:a}=await Promise.resolve().then(()=>$),{convertStreamToAsyncIterableIterator:u}=await Promise.resolve().then(()=>R),l=new o(e.options),c=s(e.options),d=t.pipeThrough(new n(l)).pipeThrough(new a(c));return void(await r(h,u(d)))}if("parseUint8ArrayStream"===n){const e=i,t=e.stream||e.data;if(!t)throw new Error("parseUint8ArrayStream with resultPort requires 'stream' or 'data' property, but both were undefined. Available properties: "+Object.keys(e).join(", "));const{FlexibleStringCSVLexer:o}=await Promise.resolve().then(()=>b),{createCSVRecordAssembler:s}=await Promise.resolve().then(()=>x),{CSVLexerTransformer:n}=await Promise.resolve().then(()=>N),{CSVRecordAssemblerTransformer:a}=await Promise.resolve().then(()=>$),{charset:u,fatal:l,ignoreBOM:c,decompression:d}=e.options??{},f={};void 0!==l&&(f.fatal=l),void 0!==c&&(f.ignoreBOM=c);const m=d?t.pipeThrough(new DecompressionStream(d)).pipeThrough(new TextDecoderStream(u??"utf-8",f)):t.pipeThrough(new TextDecoderStream(u??"utf-8",f)),{convertStreamToAsyncIterableIterator:w}=await Promise.resolve().then(()=>R),p=new o(e.options),y=s(e.options),g=m.pipeThrough(new n(p)).pipeThrough(new a(y));return void(await r(h,w(g)))}}if("parseString"===n){const r=i;if("string"==typeof r.data){if(!a){const{parseStringToIterableIterator:e}=await Promise.resolve().then(()=>P);return void(await t(o,s,e(r.data,r.options)))}try{const{parseStringToArraySyncWASM:i}=await import(e);return void(await t(o,s,i(r.data,r.options)))}catch(u){const{parseStringToIterableIterator:e}=await Promise.resolve().then(()=>P);return void(await t(o,s,e(r.data,r.options)))}}}else if("parseStream"===n){const e=i;if(e.data instanceof ReadableStream){const{FlexibleStringCSVLexer:r}=await Promise.resolve().then(()=>b),{createCSVRecordAssembler:i}=await Promise.resolve().then(()=>x),{CSVLexerTransformer:n}=await Promise.resolve().then(()=>N),{CSVRecordAssemblerTransformer:a}=await Promise.resolve().then(()=>$),{convertStreamToAsyncIterableIterator:h}=await Promise.resolve().then(()=>R),u=new r(e.options),l=i(e.options),c=e.data.pipeThrough(new n(u)).pipeThrough(new a(l));return void(await t(o,s,h(c)))}}else if("parseUint8ArrayStream"===n){const e=i;if(e.data instanceof ReadableStream){const{FlexibleStringCSVLexer:r}=await Promise.resolve().then(()=>b),{createCSVRecordAssembler:i}=await Promise.resolve().then(()=>x),{CSVLexerTransformer:n}=await Promise.resolve().then(()=>N),{CSVRecordAssemblerTransformer:a}=await Promise.resolve().then(()=>$),{charset:h,fatal:u,ignoreBOM:l,decompression:c}=e.options??{},d={};void 0!==u&&(d.fatal=u),void 0!==l&&(d.ignoreBOM=l);const f=c?e.data.pipeThrough(new DecompressionStream(c)).pipeThrough(new TextDecoderStream(h??"utf-8",d)):e.data.pipeThrough(new TextDecoderStream(h??"utf-8",d)),{convertStreamToAsyncIterableIterator:m}=await Promise.resolve().then(()=>R),w=new r(e.options),p=i(e.options),y=f.pipeThrough(new n(w)).pipeThrough(new a(p));return void(await t(o,s,m(y)))}}else{if("parseBinary"!==n)throw new Error(`Unsupported parse type: ${n}`);{const r=i;if(!a){const{parseBinaryToIterableIterator:e}=await Promise.resolve().then(()=>A);return void(await t(o,s,e(r.data,r.options)))}try{const{charset:i="utf-8",fatal:n,ignoreBOM:a,decompression:h}=r.options??{},u={};void 0!==n&&(u.fatal=n),void 0!==a&&(u.ignoreBOM=a);const l=r.data instanceof Uint8Array?r.data:new Uint8Array(r.data);let c;if(h){if("undefined"==typeof DecompressionStream)throw new Error("DecompressionStream is not available in this worker context. Decompress the data on the main thread before passing to worker.");const e=await new Response(new ReadableStream({start(e){e.enqueue(l),e.close()}}).pipeThrough(new DecompressionStream(h))).arrayBuffer();c=new TextDecoder(i,u).decode(e)}else c=new TextDecoder(i,u).decode(l);const{parseStringToArraySyncWASM:d}=await import(e);return void(await t(o,s,d(c,r.options)))}catch(u){const{parseBinaryToIterableIterator:e}=await Promise.resolve().then(()=>A);return void(await t(o,s,e(r.data,r.options)))}}}}catch(l){const e=l instanceof Error?l.message:String(l);if(h)h.postMessage({type:"error",error:e});else{const t={id:s,type:"error",error:e};o.postMessage(t)}}})(o);o.addEventListener("message",e=>{i(e.data)});const s="\r\n",n="\n",a=",",h='"',u=10485760,l=1e5,c=Symbol.for("web-csv-toolbox.FieldDelimiter"),d=Symbol.for("web-csv-toolbox.RecordDelimiter"),f=Symbol.for("web-csv-toolbox.Field");class m extends SyntaxError{position;rowNumber;source;constructor(e,t){super(e,{cause:t?.cause}),this.name="ParseError",this.position=t?.position,this.rowNumber=t?.rowNumber,this.source=t?.source}}function w(e){return e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function p(e,t){if("string"!=typeof e)throw new TypeError(`${t} must be a string`);switch(!0){case 0===e.length:throw new RangeError(`${t} must not be empty`);case e.length>1:throw new RangeError(`${t} must be a single character`);case e===n:case"\r"===e:throw new RangeError(`${t} must not include CR or LF`)}}class y{#e;#t;#r="";#o=!1;#i;#s;#n;#a={line:1,column:1,offset:0};#h=1;#u;#l;constructor(e={}){const{delimiter:t=a,quotation:r=h,maxBufferSize:o=u,signal:i,source:s}=e;!function(e){for(const r of["delimiter","quotation"])p(e[r],r);if(e.delimiter===e.quotation)throw new RangeError("delimiter must not be the same as quotation, use different characters");const t=e.maxBufferSize;if(!Number.isFinite(t)&&t!==Number.POSITIVE_INFINITY||Number.isFinite(t)&&(t<1||!Number.isInteger(t)))throw new RangeError("maxBufferSize must be a positive integer (in characters) or Number.POSITIVE_INFINITY")}({delimiter:t,quotation:r,maxBufferSize:o}),this.#e=t,this.#t=r,this.#s=t.length,this.#n=o,this.#l=s,this.#u=i;const n=w(t),l=w(r);this.#i=new RegExp(`^(?:(?!${l})(?!${n})(?![\\r\\n]))([\\S\\s\\uFEFF\\xA0]+?)(?=${l}|${n}|\\r|\\n|$)`)}lex(e,t){return(t?.stream??!1)||(this.#o=!0),void 0!==e&&0!==e.length&&(this.#r+=e,this.#c()),this.#d()}*#d(){let e;for(this.#o&&(this.#r.endsWith(s)?this.#r=this.#r.slice(0,-2):this.#r.endsWith(n)&&(this.#r=this.#r.slice(0,-1)));e=this.#f();)yield e}#c(){if(this.#r.length>this.#n)throw new RangeError(`Buffer size (${this.#r.length} characters) exceeded maximum allowed size of ${this.#n} characters`)}#f(){if(this.#u?.throwIfAborted(),0===this.#r.length)return null;if(!1===this.#o&&(this.#r===s||this.#r===n))return null;if(this.#r.startsWith(s)){this.#r=this.#r.slice(2);const e={...this.#a};this.#a.line++,this.#a.column=1,this.#a.offset+=2;return{type:d,value:s,location:{start:e,end:{...this.#a},rowNumber:this.#h++}}}if(this.#r.startsWith(n)){this.#r=this.#r.slice(1);const e={...this.#a};this.#a.line++,this.#a.column=1,this.#a.offset+=1;return{type:d,value:n,location:{start:e,end:{...this.#a},rowNumber:this.#h++}}}if(this.#r.startsWith(this.#e)){this.#r=this.#r.slice(1);const e={...this.#a};return this.#a.column+=this.#s,this.#a.offset+=this.#s,{type:c,value:this.#e,location:{start:e,end:{...this.#a},rowNumber:this.#h}}}if(this.#r.startsWith(this.#t)){let e="",t=1,r=2,o=0,i=this.#r[t];if(void 0===i){if(!1===this.#o)return null;throw new m("Unexpected EOF while parsing quoted field.",{position:{...this.#a},rowNumber:this.#h,source:this.#l})}let s=this.#r[t+1];do{if(i===this.#t){if(s===this.#t){e+=this.#t,t+=2,i=this.#r[t],s=this.#r[t+1],r+=2;continue}if(void 0===s&&!1===this.#o)return null;t++,this.#r=this.#r.slice(t);const n={...this.#a};return this.#a.column+=r,this.#a.offset+=t,this.#a.line+=o,{type:f,value:e,location:{start:n,end:{...this.#a},rowNumber:this.#h}}}e+=i,i===n?(o++,r=1):r++,t++,i=s,s=this.#r[t+1]}while(void 0!==i);if(this.#o)throw new m("Unexpected EOF while parsing quoted field.",{position:{...this.#a},rowNumber:this.#h,source:this.#l});return null}const e=this.#i.exec(this.#r);if(e){if(!1===this.#o&&e[0].length===this.#r.length)return null;const t=e[1];if(void 0===t)return null;this.#r=this.#r.slice(t.length);const r={...this.#a};return this.#a.column+=t.length,this.#a.offset+=t.length,{type:f,value:t,location:{start:r,end:{...this.#a},rowNumber:this.#h}}}return null}}const b=/*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({__proto__:null,FlexibleStringCSVLexer:y},Symbol.toStringTag,{value:"Module"}));class g{#m=0;#w=[];#p;#y=!1;#u;#b;#g;#S;#l;#v;#x;#I=!1;constructor(e={}){if(this.#v=e.includeHeader??!1,void 0!==e.header&&Array.isArray(e.header)&&0===e.header.length&&void 0!==e.columnCountStrategy&&"keep"!==e.columnCountStrategy)throw new Error(`Headerless mode (header: []) only supports columnCountStrategy: 'keep'. Got '${e.columnCountStrategy}'. For other strategies, provide a non-empty header.`);if(this.#x=e.columnCountStrategy??"keep","keep"!==this.#x&&void 0===e.header)throw new Error(`columnCountStrategy '${this.#x}' requires header option. Use 'keep' or omit columnCountStrategy for headerless CSV.`);const t=e.maxFieldCount??l;if(!Number.isFinite(t)&&t!==Number.POSITIVE_INFINITY||Number.isFinite(t)&&(t<1||!Number.isInteger(t)))throw new RangeError("maxFieldCount must be a positive integer or Number.POSITIVE_INFINITY");this.#b=t,this.#g=e.skipEmptyLines??!1,this.#l=e.source,void 0!==e.header&&Array.isArray(e.header)&&this.#T(e.header),e.signal&&(this.#u=e.signal)}*assemble(e,t){const r=t?.stream??!1;if(yield*this.#C(),void 0!==e)if(this.#N(e))for(const o of e)yield*this.#E(o);else yield*this.#E(e);r||(yield*this.#o())}#N(e){return null!=e&&"function"==typeof e[Symbol.iterator]}*#E(e){switch(this.#u?.throwIfAborted(),e.location&&(this.#S=e.location.rowNumber),e.type){case c:void 0===this.#w[this.#m]&&(this.#w[this.#m]=""),this.#m++,this.#F(),this.#y=!0;break;case d:void 0===this.#w[this.#m]&&(this.#w[this.#m]=""),void 0===this.#p?(this.#T(this.#w),yield*this.#C()):this.#y?yield this.#k():this.#g||(yield new Array(this.#p.length).fill("")),this.#m=0,this.#w=[],this.#y=!1;break;default:this.#y=!0,this.#w[this.#m]=e.value}}*#o(){void 0!==this.#p&&this.#y&&(void 0===this.#w[this.#m]&&(this.#w[this.#m]=""),yield this.#k())}#F(){if(this.#m+1>this.#b)throw new RangeError(`Field count (${this.#m+1}) exceeded maximum allowed count of ${this.#b}${this.#S?` at row ${this.#S}`:""}${this.#l?` in ${JSON.stringify(this.#l)}`:""}`)}#T(e){if(e.length>this.#b)throw new RangeError(`Header field count (${e.length}) exceeded maximum allowed count of ${this.#b}${this.#l?` in ${JSON.stringify(this.#l)}`:""}`);if(this.#p=e,this.#p.length>0&&new Set(this.#p).size!==this.#p.length)throw new m("The header must not contain duplicate fields.",{source:this.#l})}#k(){if(!this.#p)return[...this.#w];const e=this.#p.length,t=this.#w.length;switch(this.#x){case"keep":default:return[...this.#w];case"pad":if(t<e){const t=[...this.#w];for(;t.length<e;)t.push(void 0);return t}return t>e?this.#w.slice(0,e):[...this.#w];case"strict":if(t!==e)throw new m(`Expected ${e} columns, got ${t}${this.#S?` at row ${this.#S}`:""}${this.#l?` in ${JSON.stringify(this.#l)}`:""}`,{source:this.#l});return[...this.#w];case"truncate":return t>e?this.#w.slice(0,e):[...this.#w]}}*#C(){this.#v&&void 0!==this.#p&&!this.#I&&(this.#I=!0,yield[...this.#p])}}class S{#m=0;#w=[];#p;#y=!1;#u;#b;#g;#S;#l;#x;constructor(e={}){if(this.#x=e.columnCountStrategy??"pad","keep"===this.#x&&(console.warn("columnCountStrategy 'keep' has no effect in object format. Object format always maps to header keys. Falling back to 'pad' strategy."),this.#x="pad"),"pad"!==this.#x&&void 0===e.header)throw new Error(`columnCountStrategy '${this.#x}' requires header option. Use 'pad' or omit columnCountStrategy for headerless CSV.`);const t=e.maxFieldCount??l;if(!Number.isFinite(t)&&t!==Number.POSITIVE_INFINITY||Number.isFinite(t)&&(t<1||!Number.isInteger(t)))throw new RangeError("maxFieldCount must be a positive integer or Number.POSITIVE_INFINITY");this.#b=t,this.#g=e.skipEmptyLines??!1,this.#l=e.source,void 0!==e.header&&Array.isArray(e.header)&&this.#T(e.header),e.signal&&(this.#u=e.signal)}*assemble(e,t){const r=t?.stream??!1;if(void 0!==e)if(this.#N(e))for(const o of e)yield*this.#E(o);else yield*this.#E(e);r||(yield*this.#o())}#N(e){return null!=e&&"function"==typeof e[Symbol.iterator]}*#E(e){switch(this.#u?.throwIfAborted(),e.location&&(this.#S=e.location.rowNumber),e.type){case c:void 0===this.#w[this.#m]&&(this.#w[this.#m]=""),this.#m++,this.#F(),this.#y=!0;break;case d:void 0===this.#w[this.#m]&&(this.#w[this.#m]=""),void 0===this.#p?this.#T(this.#w):this.#y?yield this.#k():this.#g||(yield Object.fromEntries(this.#p.filter(e=>e).map(e=>[e,""]))),this.#m=0,this.#w=[],this.#y=!1;break;default:this.#y=!0,this.#w[this.#m]=e.value}}*#o(){void 0!==this.#p&&this.#y&&(void 0===this.#w[this.#m]&&(this.#w[this.#m]=""),yield this.#k())}#F(){if(this.#m+1>this.#b)throw new RangeError(`Field count (${this.#m+1}) exceeded maximum allowed count of ${this.#b}${this.#S?` at row ${this.#S}`:""}${this.#l?` in ${JSON.stringify(this.#l)}`:""}`)}#T(e){if(e.length>this.#b)throw new RangeError(`Header field count (${e.length}) exceeded maximum allowed count of ${this.#b}${this.#l?` in ${JSON.stringify(this.#l)}`:""}`);if(this.#p=e,0===this.#p.length)throw new m("Headerless mode (header: []) is not supported for object format. Use array format (outputFormat: 'array') for headerless CSV, or provide a non-empty header for object format.",{source:this.#l});if(new Set(this.#p).size!==this.#p.length)throw new m("The header must not contain duplicate fields.",{source:this.#l})}#k(){if(!this.#p)return{};const e=this.#p.length,t=this.#w.length;switch(this.#x){case"pad":default:return Object.fromEntries(this.#p.map((e,t)=>[e,t]).filter(([e])=>e).map(([e,t])=>[e,this.#w.at(t)]));case"strict":if(t!==e)throw new m(`Expected ${e} columns, got ${t}${this.#S?` at row ${this.#S}`:""}${this.#l?` in ${JSON.stringify(this.#l)}`:""}`,{source:this.#l});return Object.fromEntries(this.#p.map((e,t)=>[e,t]).filter(([e])=>e).map(([e,t])=>[e,this.#w[t]]));case"truncate":return Object.fromEntries(this.#p.map((e,t)=>[e,t]).filter(([e])=>e).map(([e,t])=>[e,this.#w[t]]))}}}function v(e){const t=e?.outputFormat??"object";if(void 0!==e?.header&&Array.isArray(e.header)&&0===e.header.length){if("array"!==t)throw new Error(`Headerless mode (header: []) is not supported for outputFormat: '${t}'. Use outputFormat: 'array' for headerless CSV, or provide a non-empty header for object format.`);if(void 0!==e.columnCountStrategy&&"keep"!==e.columnCountStrategy)throw new Error(`Headerless mode (header: []) only supports columnCountStrategy: 'keep'. Got '${e.columnCountStrategy}'. For other strategies, provide a non-empty header.`)}if(e&&"includeHeader"in e&&e.includeHeader&&"array"!==t)throw new Error("includeHeader option is only valid for array format");return"array"===t?new g(e??{}):new S(e??{})}const x=/*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({__proto__:null,createCSVRecordAssembler:v},Symbol.toStringTag,{value:"Module"})),I={highWaterMark:65536,size:e=>e.length},T=new CountQueuingStrategy({highWaterMark:1024});class C extends TransformStream{lexer;async yieldToEventLoop(){await new Promise(e=>setTimeout(e,0))}constructor(e,t={},r=I,o=T){const i=t.backpressureCheckInterval??100;super({transform:async(t,r)=>{if(0!==t.length)try{let o=0;for(const s of e.lex(t,{stream:!0}))r.enqueue(s),o++,o%i===0&&null!==r.desiredSize&&r.desiredSize<=0&&await this.yieldToEventLoop()}catch(o){r.error(o)}},flush:async t=>{try{let r=0;for(const o of e.lex())t.enqueue(o),r++,r%i===0&&null!==t.desiredSize&&t.desiredSize<=0&&await this.yieldToEventLoop()}catch(r){t.error(r)}}},r,o),this.lexer=e}}const N=/*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({__proto__:null,CSVLexerTransformer:C},Symbol.toStringTag,{value:"Module"})),E=new CountQueuingStrategy({highWaterMark:1024}),F=new CountQueuingStrategy({highWaterMark:256});class k extends TransformStream{assembler;async yieldToEventLoop(){await new Promise(e=>setTimeout(e,0))}constructor(e,t={},r=E,o=F){const i=t.backpressureCheckInterval??10;super({transform:async(t,r)=>{try{let o=0;for(const s of e.assemble(t,{stream:!0}))r.enqueue(s),o++,o%i===0&&null!==r.desiredSize&&r.desiredSize<=0&&await this.yieldToEventLoop()}catch(o){r.error(o)}},flush:async t=>{try{let r=0;for(const o of e.assemble())t.enqueue(o),r++,r%i===0&&null!==t.desiredSize&&t.desiredSize<=0&&await this.yieldToEventLoop()}catch(r){t.error(r)}}},r,o),this.assembler=e}}const $=/*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({__proto__:null,CSVRecordAssemblerTransformer:k},Symbol.toStringTag,{value:"Module"}));const R=/*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({__proto__:null,convertStreamToAsyncIterableIterator:function(e){return Symbol.asyncIterator in e&&"function"==typeof e[Symbol.asyncIterator]?e[Symbol.asyncIterator]():async function*(){const t=e.getReader();let r=!1,o=!1;try{for(;;){const{done:e,value:o}=await t.read();if(e){r=!0;break}yield o}}catch(i){throw o=!0,await t.cancel(i).catch(()=>{}),i}finally{r||o||await t.cancel().catch(()=>{}),t.releaseLock()}}()}},Symbol.toStringTag,{value:"Module"}));function O(e){if(e instanceof m||e instanceof RangeError||e instanceof TypeError||"undefined"!=typeof DOMException&&e instanceof DOMException)throw e;throw new m("An error occurred while parsing the CSV data.",{cause:e})}function _(e,t){try{const r=new y(t),o=v(t),i=r.lex(e);return o.assemble(i)}catch(r){O(r)}}const P=/*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({__proto__:null,parseStringToIterableIterator:_},Symbol.toStringTag,{value:"Module"}));const A=/*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({__proto__:null,parseBinaryToIterableIterator:function(e,t){try{const r=function(e,t){const r=t?.maxBinarySize??104857600;if(!Number.isFinite(r)&&r!==Number.POSITIVE_INFINITY||Number.isFinite(r)&&r<0)throw new RangeError("maxBinarySize must be a non-negative number or Number.POSITIVE_INFINITY");if(Number.isFinite(r)&&e.byteLength>r)throw new RangeError(`Binary size (${e.byteLength} bytes) exceeded maximum allowed size of ${r} bytes`);let o;try{const e={};void 0!==t?.ignoreBOM&&(e.ignoreBOM=t.ignoreBOM),void 0!==t?.fatal&&(e.fatal=t.fatal),o=new TextDecoder(t?.charset,e)}catch(i){if(i instanceof RangeError||i instanceof TypeError)throw new RangeError(`Invalid or unsupported charset: "${t?.charset}". Please specify a valid charset or enable allowNonStandardCharsets option.`);throw i}return o.decode(e instanceof ArrayBuffer?new Uint8Array(e):e)}(e,t??{});return _(r,t)}catch(r){O(r)}}},Symbol.toStringTag,{value:"Module"}));
//# sourceMappingURL=worker.slim.web.bundle.js.map
