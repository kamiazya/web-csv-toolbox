const e="../../parser/api/string/parseStringToArraySyncWASM.slim.ts",t=async(e,t,r)=>{try{for await(const i of r){const r={id:t,type:"record",record:i};e.postMessage(r)}const i={id:t,type:"done"};e.postMessage(i)}catch(r){const i={id:t,type:"error",error:r instanceof Error?r.message:String(r)};e.postMessage(i)}},r=async(e,t)=>{try{for await(const r of t)e.postMessage({type:"record",record:r});e.postMessage({type:"done"})}catch(t){e.postMessage({type:"error",error:t instanceof Error?t.message:String(t)})}};"undefined"!=typeof globalThis&&(globalThis.__vitest_browser_runner__||(globalThis.__vitest_browser_runner__={wrapDynamicImport:e=>e()}));const o=self,i=(i=>async s=>{const{id:o,type:n,useWASM:a,resultPort:h}=s;try{if(h){if("parseStringStream"===n){const e=s,t=e.stream||e.data;if(!t)throw new Error("parseStringStream with resultPort requires 'stream' or 'data' property, but both were undefined. Available properties: "+Object.keys(e).join(", "));const{FlexibleStringCSVLexer:i}=await Promise.resolve().then(()=>b),{createCSVRecordAssembler:o}=await Promise.resolve().then(()=>x),{CSVLexerTransformer:n}=await Promise.resolve().then(()=>N),{CSVRecordAssemblerTransformer:a}=await Promise.resolve().then(()=>$),{convertStreamToAsyncIterableIterator:l}=await Promise.resolve().then(()=>R),c=new i(e.options),u=o(e.options),d=t.pipeThrough(new n(c)).pipeThrough(new a(u));return void await r(h,l(d))}if("parseUint8ArrayStream"===n){const e=s,t=e.stream||e.data;if(!t)throw new Error("parseUint8ArrayStream with resultPort requires 'stream' or 'data' property, but both were undefined. Available properties: "+Object.keys(e).join(", "));const{FlexibleStringCSVLexer:i}=await Promise.resolve().then(()=>b),{createCSVRecordAssembler:o}=await Promise.resolve().then(()=>x),{CSVLexerTransformer:n}=await Promise.resolve().then(()=>N),{CSVRecordAssemblerTransformer:a}=await Promise.resolve().then(()=>$),{charset:l,fatal:c,ignoreBOM:u,decompression:d}=e.options??{},m={};void 0!==c&&(m.fatal=c),void 0!==u&&(m.ignoreBOM=u);const f=d?t.pipeThrough(new DecompressionStream(d)).pipeThrough(new TextDecoderStream(l??"utf-8",m)):t.pipeThrough(new TextDecoderStream(l??"utf-8",m)),{convertStreamToAsyncIterableIterator:p}=await Promise.resolve().then(()=>R),w=new i(e.options),y=o(e.options),g=f.pipeThrough(new n(w)).pipeThrough(new a(y));return void await r(h,p(g))}}if("parseString"===n){const r=s;if("string"==typeof r.data){if(!a){const{parseStringToIterableIterator:e}=await Promise.resolve().then(()=>P);return void await t(i,o,e(r.data,r.options))}try{const{parseStringToArraySyncWASM:s}=await import(e);return void await t(i,o,s(r.data,r.options))}catch(e){const{parseStringToIterableIterator:s}=await Promise.resolve().then(()=>P);return void await t(i,o,s(r.data,r.options))}}}else if("parseStream"===n){const e=s;if(e.data instanceof ReadableStream){const{FlexibleStringCSVLexer:r}=await Promise.resolve().then(()=>b),{createCSVRecordAssembler:s}=await Promise.resolve().then(()=>x),{CSVLexerTransformer:n}=await Promise.resolve().then(()=>N),{CSVRecordAssemblerTransformer:a}=await Promise.resolve().then(()=>$),{convertStreamToAsyncIterableIterator:h}=await Promise.resolve().then(()=>R),l=new r(e.options),c=s(e.options),u=e.data.pipeThrough(new n(l)).pipeThrough(new a(c));return void await t(i,o,h(u))}}else if("parseUint8ArrayStream"===n){const e=s;if(e.data instanceof ReadableStream){const{FlexibleStringCSVLexer:r}=await Promise.resolve().then(()=>b),{createCSVRecordAssembler:s}=await Promise.resolve().then(()=>x),{CSVLexerTransformer:n}=await Promise.resolve().then(()=>N),{CSVRecordAssemblerTransformer:a}=await Promise.resolve().then(()=>$),{charset:h,fatal:l,ignoreBOM:c,decompression:u}=e.options??{},d={};void 0!==l&&(d.fatal=l),void 0!==c&&(d.ignoreBOM=c);const m=u?e.data.pipeThrough(new DecompressionStream(u)).pipeThrough(new TextDecoderStream(h??"utf-8",d)):e.data.pipeThrough(new TextDecoderStream(h??"utf-8",d)),{convertStreamToAsyncIterableIterator:f}=await Promise.resolve().then(()=>R),p=new r(e.options),w=s(e.options),y=m.pipeThrough(new n(p)).pipeThrough(new a(w));return void await t(i,o,f(y))}}else{if("parseBinary"!==n)throw new Error(`Unsupported parse type: ${n}`);{const r=s;if(!a){const{parseBinaryToIterableIterator:e}=await Promise.resolve().then(()=>A);return void await t(i,o,e(r.data,r.options))}try{const{charset:s="utf-8",fatal:n,ignoreBOM:a,decompression:h}=r.options??{},l={};void 0!==n&&(l.fatal=n),void 0!==a&&(l.ignoreBOM=a);const c=r.data instanceof Uint8Array?r.data:new Uint8Array(r.data);let u;if(h){if("undefined"==typeof DecompressionStream)throw new Error("DecompressionStream is not available in this worker context. Decompress the data on the main thread before passing to worker.");const e=await new Response(new ReadableStream({start(e){e.enqueue(c),e.close()}}).pipeThrough(new DecompressionStream(h))).arrayBuffer();u=new TextDecoder(s,l).decode(e)}else u=new TextDecoder(s,l).decode(c);const{parseStringToArraySyncWASM:d}=await import(e);return void await t(i,o,d(u,r.options))}catch(e){const{parseBinaryToIterableIterator:s}=await Promise.resolve().then(()=>A);return void await t(i,o,s(r.data,r.options))}}}}catch(e){const t=e instanceof Error?e.message:String(e);if(h)h.postMessage({type:"error",error:t});else{const e={id:o,type:"error",error:t};i.postMessage(e)}}})(o);o.addEventListener("message",e=>{i(e.data)});const s="\r\n",n="\n",a=",",h='"',u=10485760,l=1e5,c=Symbol.for("web-csv-toolbox.FieldDelimiter"),d=Symbol.for("web-csv-toolbox.RecordDelimiter"),f=Symbol.for("web-csv-toolbox.Field");class m extends SyntaxError{position;rowNumber;source;constructor(e,t){super(e,{cause:t?.cause}),this.name="ParseError",this.position=t?.position,this.rowNumber=t?.rowNumber,this.source=t?.source}}function w(e){return e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function p(e,t){if("string"!=typeof e)throw new TypeError(`${t} must be a string`);switch(!0){case 0===e.length:throw new RangeError(`${t} must not be empty`);case e.length>1:throw new RangeError(`${t} must be a single character`);case e===n:case"\r"===e:throw new RangeError(`${t} must not include CR or LF`)}}class y{#e;#t;#r="";#i=!1;#s;#o;#n;#a={line:1,column:1,offset:0};#h=1;#l;#c;constructor(e={}){const{delimiter:t=a,quotation:r=h,maxBufferSize:i=u,signal:s,source:o}=e;!function(e){for(const t of["delimiter","quotation"])p(e[t],t);if(e.delimiter===e.quotation)throw new RangeError("delimiter must not be the same as quotation, use different characters");const t=e.maxBufferSize;if(!Number.isFinite(t)&&t!==Number.POSITIVE_INFINITY||Number.isFinite(t)&&(t<1||!Number.isInteger(t)))throw new RangeError("maxBufferSize must be a positive integer (in characters) or Number.POSITIVE_INFINITY")}({delimiter:t,quotation:r,maxBufferSize:i}),this.#e=t,this.#t=r,this.#o=t.length,this.#n=i,this.#c=o,this.#l=s;const n=w(t),l=w(r);this.#s=new RegExp(`^(?:(?!${l})(?!${n})(?![\\r\\n]))([\\S\\s\\uFEFF\\xA0]+?)(?=${l}|${n}|\\r|\\n|$)`)}lex(e,t){return(t?.stream??!1)||(this.#i=!0),void 0!==e&&0!==e.length&&(this.#r+=e,this.#u()),this.#d()}*#d(){let e;for(this.#i&&(this.#r.endsWith(s)?this.#r=this.#r.slice(0,-2):this.#r.endsWith(n)&&(this.#r=this.#r.slice(0,-1)));e=this.#m();)yield e}#u(){if(this.#r.length>this.#n)throw new RangeError(`Buffer size (${this.#r.length} characters) exceeded maximum allowed size of ${this.#n} characters`)}#m(){if(this.#l?.throwIfAborted(),0===this.#r.length)return null;if(!1===this.#i&&(this.#r===s||this.#r===n))return null;if(this.#r.startsWith(s)){this.#r=this.#r.slice(2);const e={...this.#a};return this.#a.line++,this.#a.column=1,this.#a.offset+=2,{type:d,value:s,location:{start:e,end:{...this.#a},rowNumber:this.#h++}}}if(this.#r.startsWith(n)){this.#r=this.#r.slice(1);const e={...this.#a};return this.#a.line++,this.#a.column=1,this.#a.offset+=1,{type:d,value:n,location:{start:e,end:{...this.#a},rowNumber:this.#h++}}}if(this.#r.startsWith(this.#e)){this.#r=this.#r.slice(1);const e={...this.#a};return this.#a.column+=this.#o,this.#a.offset+=this.#o,{type:c,value:this.#e,location:{start:e,end:{...this.#a},rowNumber:this.#h}}}if(this.#r.startsWith(this.#t)){let e="",t=1,r=2,i=0,s=this.#r[t];if(void 0===s){if(!1===this.#i)return null;throw new m("Unexpected EOF while parsing quoted field.",{position:{...this.#a},rowNumber:this.#h,source:this.#c})}let o=this.#r[t+1];do{if(s===this.#t){if(o===this.#t){e+=this.#t,t+=2,s=this.#r[t],o=this.#r[t+1],r+=2;continue}if(void 0===o&&!1===this.#i)return null;t++,this.#r=this.#r.slice(t);const n={...this.#a};return this.#a.column+=r,this.#a.offset+=t,this.#a.line+=i,{type:f,value:e,location:{start:n,end:{...this.#a},rowNumber:this.#h}}}e+=s,s===n?(i++,r=1):r++,t++,s=o,o=this.#r[t+1]}while(void 0!==s);if(this.#i)throw new m("Unexpected EOF while parsing quoted field.",{position:{...this.#a},rowNumber:this.#h,source:this.#c});return null}const e=this.#s.exec(this.#r);if(e){if(!1===this.#i&&e[0].length===this.#r.length)return null;const t=e[1];if(void 0===t)return null;this.#r=this.#r.slice(t.length);const r={...this.#a};return this.#a.column+=t.length,this.#a.offset+=t.length,{type:f,value:t,location:{start:r,end:{...this.#a},rowNumber:this.#h}}}return null}}const b=Object.freeze(Object.defineProperty({__proto__:null,FlexibleStringCSVLexer:y},Symbol.toStringTag,{value:"Module"}));class g{#f=0;#p=[];#w;#y=!1;#l;#g;#b;#S;#c;#v;#T;#x=!1;constructor(e={}){if(this.#v=e.includeHeader??!1,void 0!==e.header&&Array.isArray(e.header)&&0===e.header.length&&void 0!==e.columnCountStrategy&&"keep"!==e.columnCountStrategy)throw new Error(`Headerless mode (header: []) only supports columnCountStrategy: 'keep'. Got '${e.columnCountStrategy}'. For other strategies, provide a non-empty header.`);if(this.#T=e.columnCountStrategy??"keep","keep"!==this.#T&&void 0===e.header)throw new Error(`columnCountStrategy '${this.#T}' requires header option. Use 'keep' or omit columnCountStrategy for headerless CSV.`);const t=e.maxFieldCount??l;if(!Number.isFinite(t)&&t!==Number.POSITIVE_INFINITY||Number.isFinite(t)&&(t<1||!Number.isInteger(t)))throw new RangeError("maxFieldCount must be a positive integer or Number.POSITIVE_INFINITY");this.#g=t,this.#b=e.skipEmptyLines??!1,this.#c=e.source,void 0!==e.header&&Array.isArray(e.header)&&this.#I(e.header),e.signal&&(this.#l=e.signal)}*assemble(e,t){const r=t?.stream??!1;if(yield*this.#E(),void 0!==e)if(this.#N(e))for(const t of e)yield*this.#$(t);else yield*this.#$(e);r||(yield*this.#i())}#N(e){return null!=e&&"function"==typeof e[Symbol.iterator]}*#$(e){switch(this.#l?.throwIfAborted(),e.location&&(this.#S=e.location.rowNumber),e.type){case c:void 0===this.#p[this.#f]&&(this.#p[this.#f]=""),this.#f++,this.#C(),this.#y=!0;break;case d:void 0===this.#p[this.#f]&&(this.#p[this.#f]=""),void 0===this.#w?(this.#I(this.#p),yield*this.#E()):this.#y?yield this.#O():this.#b||(yield new Array(this.#w.length).fill("")),this.#f=0,this.#p=[],this.#y=!1;break;default:this.#y=!0,this.#p[this.#f]=e.value}}*#i(){void 0!==this.#w&&this.#y&&(void 0===this.#p[this.#f]&&(this.#p[this.#f]=""),yield this.#O())}#C(){if(this.#f+1>this.#g)throw new RangeError(`Field count (${this.#f+1}) exceeded maximum allowed count of ${this.#g}${this.#S?` at row ${this.#S}`:""}${this.#c?` in ${JSON.stringify(this.#c)}`:""}`)}#I(e){if(e.length>this.#g)throw new RangeError(`Header field count (${e.length}) exceeded maximum allowed count of ${this.#g}${this.#c?` in ${JSON.stringify(this.#c)}`:""}`);if(this.#w=e,this.#w.length>0&&new Set(this.#w).size!==this.#w.length)throw new m("The header must not contain duplicate fields.",{source:this.#c})}#O(){if(!this.#w)return[...this.#p];const e=this.#w.length,t=this.#p.length;switch(this.#T){case"keep":default:return[...this.#p];case"pad":if(t<e){const t=[...this.#p];for(;t.length<e;)t.push(void 0);return t}return t>e?this.#p.slice(0,e):[...this.#p];case"strict":if(t!==e)throw new m(`Expected ${e} columns, got ${t}${this.#S?` at row ${this.#S}`:""}${this.#c?` in ${JSON.stringify(this.#c)}`:""}`,{source:this.#c});return[...this.#p];case"truncate":return t>e?this.#p.slice(0,e):[...this.#p]}}*#E(){this.#v&&void 0!==this.#w&&!this.#x&&(this.#x=!0,yield[...this.#w])}}class S{#f=0;#p=[];#w;#y=!1;#l;#g;#b;#S;#c;#T;constructor(e={}){if(this.#T=e.columnCountStrategy??"pad","keep"===this.#T&&(console.warn("columnCountStrategy 'keep' has no effect in object format. Object format always maps to header keys. Falling back to 'pad' strategy."),this.#T="pad"),"pad"!==this.#T&&void 0===e.header)throw new Error(`columnCountStrategy '${this.#T}' requires header option. Use 'pad' or omit columnCountStrategy for headerless CSV.`);const t=e.maxFieldCount??l;if(!Number.isFinite(t)&&t!==Number.POSITIVE_INFINITY||Number.isFinite(t)&&(t<1||!Number.isInteger(t)))throw new RangeError("maxFieldCount must be a positive integer or Number.POSITIVE_INFINITY");this.#g=t,this.#b=e.skipEmptyLines??!1,this.#c=e.source,void 0!==e.header&&Array.isArray(e.header)&&this.#I(e.header),e.signal&&(this.#l=e.signal)}*assemble(e,t){const r=t?.stream??!1;if(void 0!==e)if(this.#N(e))for(const t of e)yield*this.#$(t);else yield*this.#$(e);r||(yield*this.#i())}#N(e){return null!=e&&"function"==typeof e[Symbol.iterator]}*#$(e){switch(this.#l?.throwIfAborted(),e.location&&(this.#S=e.location.rowNumber),e.type){case c:void 0===this.#p[this.#f]&&(this.#p[this.#f]=""),this.#f++,this.#C(),this.#y=!0;break;case d:void 0===this.#p[this.#f]&&(this.#p[this.#f]=""),void 0===this.#w?this.#I(this.#p):this.#y?yield this.#O():this.#b||(yield Object.fromEntries(this.#w.filter(e=>e).map(e=>[e,""]))),this.#f=0,this.#p=[],this.#y=!1;break;default:this.#y=!0,this.#p[this.#f]=e.value}}*#i(){void 0!==this.#w&&this.#y&&(void 0===this.#p[this.#f]&&(this.#p[this.#f]=""),yield this.#O())}#C(){if(this.#f+1>this.#g)throw new RangeError(`Field count (${this.#f+1}) exceeded maximum allowed count of ${this.#g}${this.#S?` at row ${this.#S}`:""}${this.#c?` in ${JSON.stringify(this.#c)}`:""}`)}#I(e){if(e.length>this.#g)throw new RangeError(`Header field count (${e.length}) exceeded maximum allowed count of ${this.#g}${this.#c?` in ${JSON.stringify(this.#c)}`:""}`);if(this.#w=e,0===this.#w.length)throw new m("Headerless mode (header: []) is not supported for object format. Use array format (outputFormat: 'array') for headerless CSV, or provide a non-empty header for object format.",{source:this.#c});if(new Set(this.#w).size!==this.#w.length)throw new m("The header must not contain duplicate fields.",{source:this.#c})}#O(){if(!this.#w)return{};const e=this.#w.length,t=this.#p.length;switch(this.#T){case"pad":default:return Object.fromEntries(this.#w.map((e,t)=>[e,t]).filter(([e])=>e).map(([e,t])=>[e,this.#p.at(t)]));case"strict":if(t!==e)throw new m(`Expected ${e} columns, got ${t}${this.#S?` at row ${this.#S}`:""}${this.#c?` in ${JSON.stringify(this.#c)}`:""}`,{source:this.#c});return Object.fromEntries(this.#w.map((e,t)=>[e,t]).filter(([e])=>e).map(([e,t])=>[e,this.#p[t]]));case"truncate":return Object.fromEntries(this.#w.map((e,t)=>[e,t]).filter(([e])=>e).map(([e,t])=>[e,this.#p[t]]))}}}function v(e){const t=e?.outputFormat??"object";if(void 0!==e?.header&&Array.isArray(e.header)&&0===e.header.length){if("array"!==t)throw new Error(`Headerless mode (header: []) is not supported for outputFormat: '${t}'. Use outputFormat: 'array' for headerless CSV, or provide a non-empty header for object format.`);if(void 0!==e.columnCountStrategy&&"keep"!==e.columnCountStrategy)throw new Error(`Headerless mode (header: []) only supports columnCountStrategy: 'keep'. Got '${e.columnCountStrategy}'. For other strategies, provide a non-empty header.`)}if(e&&"includeHeader"in e&&e.includeHeader&&"array"!==t)throw new Error("includeHeader option is only valid for array format");return"array"===t?new g(e??{}):new S(e??{})}const x=Object.freeze(Object.defineProperty({__proto__:null,createCSVRecordAssembler:v},Symbol.toStringTag,{value:"Module"})),I={highWaterMark:65536,size:e=>e.length},T=new CountQueuingStrategy({highWaterMark:1024});class C extends TransformStream{lexer;async yieldToEventLoop(){await new Promise(e=>setTimeout(e,0))}constructor(e,t={},r=I,i=T){const s=t.backpressureCheckInterval??100;super({transform:async(t,r)=>{if(0!==t.length)try{let i=0;for(const o of e.lex(t,{stream:!0}))r.enqueue(o),i++,i%s===0&&null!==r.desiredSize&&r.desiredSize<=0&&await this.yieldToEventLoop()}catch(e){r.error(e)}},flush:async t=>{try{let r=0;for(const i of e.lex())t.enqueue(i),r++,r%s===0&&null!==t.desiredSize&&t.desiredSize<=0&&await this.yieldToEventLoop()}catch(e){t.error(e)}}},r,i),this.lexer=e}}const N=Object.freeze(Object.defineProperty({__proto__:null,CSVLexerTransformer:C},Symbol.toStringTag,{value:"Module"})),E=new CountQueuingStrategy({highWaterMark:1024}),F=new CountQueuingStrategy({highWaterMark:256});class k extends TransformStream{assembler;async yieldToEventLoop(){await new Promise(e=>setTimeout(e,0))}constructor(e,t={},r=E,i=F){const s=t.backpressureCheckInterval??10;super({transform:async(t,r)=>{try{let i=0;for(const o of e.assemble(t,{stream:!0}))r.enqueue(o),i++,i%s===0&&null!==r.desiredSize&&r.desiredSize<=0&&await this.yieldToEventLoop()}catch(e){r.error(e)}},flush:async t=>{try{let r=0;for(const i of e.assemble())t.enqueue(i),r++,r%s===0&&null!==t.desiredSize&&t.desiredSize<=0&&await this.yieldToEventLoop()}catch(e){t.error(e)}}},r,i),this.assembler=e}}const $=Object.freeze(Object.defineProperty({__proto__:null,CSVRecordAssemblerTransformer:k},Symbol.toStringTag,{value:"Module"})),R=Object.freeze(Object.defineProperty({__proto__:null,convertStreamToAsyncIterableIterator:function(e){return Symbol.asyncIterator in e&&"function"==typeof e[Symbol.asyncIterator]?e[Symbol.asyncIterator]():async function*(){const t=e.getReader();let r=!1,i=!1;try{for(;;){const{done:e,value:i}=await t.read();if(e){r=!0;break}yield i}}catch(e){throw i=!0,await t.cancel(e).catch(()=>{}),e}finally{r||i||await t.cancel().catch(()=>{}),t.releaseLock()}}()}},Symbol.toStringTag,{value:"Module"}));function O(e){if(e instanceof m||e instanceof RangeError||e instanceof TypeError||"undefined"!=typeof DOMException&&e instanceof DOMException)throw e;throw new m("An error occurred while parsing the CSV data.",{cause:e})}function _(e,t){try{const r=new y(t),i=v(t),s=r.lex(e);return i.assemble(s)}catch(e){O(e)}}const P=Object.freeze(Object.defineProperty({__proto__:null,parseStringToIterableIterator:_},Symbol.toStringTag,{value:"Module"})),A=Object.freeze(Object.defineProperty({__proto__:null,parseBinaryToIterableIterator:function(e,t){try{const r=function(e,t){const r=t?.maxBinarySize??104857600;if(!Number.isFinite(r)&&r!==Number.POSITIVE_INFINITY||Number.isFinite(r)&&r<0)throw new RangeError("maxBinarySize must be a non-negative number or Number.POSITIVE_INFINITY");if(Number.isFinite(r)&&e.byteLength>r)throw new RangeError(`Binary size (${e.byteLength} bytes) exceeded maximum allowed size of ${r} bytes`);let i;try{const e={};void 0!==t?.ignoreBOM&&(e.ignoreBOM=t.ignoreBOM),void 0!==t?.fatal&&(e.fatal=t.fatal),i=new TextDecoder(t?.charset,e)}catch(e){if(e instanceof RangeError||e instanceof TypeError)throw new RangeError(`Invalid or unsupported charset: "${t?.charset}". Please specify a valid charset or enable allowNonStandardCharsets option.`);throw e}return i.decode(e instanceof ArrayBuffer?new Uint8Array(e):e)}(e,t??{});return _(r,t)}catch(e){O(e)}}},Symbol.toStringTag,{value:"Module"}));