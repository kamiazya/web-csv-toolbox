<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Non-blocking WASM CSV Parser Demo</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
    }

    h1 {
      color: #333;
      border-bottom: 3px solid #4CAF50;
      padding-bottom: 10px;
    }

    .container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-top: 20px;
    }

    .panel {
      background: white;
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .panel h2 {
      margin-top: 0;
      color: #555;
      font-size: 1.2em;
    }

    .counter {
      font-size: 48px;
      font-weight: bold;
      text-align: center;
      padding: 20px;
      margin: 20px 0;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border-radius: 8px;
      animation: pulse 1s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    button {
      width: 100%;
      padding: 15px;
      margin: 10px 0;
      font-size: 16px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.3s;
      font-weight: 600;
    }

    button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn-blocking {
      background: #ff5252;
      color: white;
    }

    .btn-blocking:hover:not(:disabled) {
      background: #ff1744;
    }

    .btn-nonblocking {
      background: #4CAF50;
      color: white;
    }

    .btn-nonblocking:hover:not(:disabled) {
      background: #43a047;
    }

    .status {
      padding: 15px;
      margin: 10px 0;
      border-radius: 6px;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      max-height: 400px;
      overflow-y: auto;
    }

    .status.idle {
      background: #e3f2fd;
      color: #1976d2;
    }

    .status.working {
      background: #fff3e0;
      color: #f57c00;
    }

    .status.done {
      background: #e8f5e9;
      color: #388e3c;
    }

    .status.error {
      background: #ffebee;
      color: #c62828;
    }

    .info {
      background: #e3f2fd;
      padding: 15px;
      border-radius: 6px;
      margin-bottom: 20px;
      border-left: 4px solid #2196f3;
    }

    .warning {
      background: #fff3e0;
      padding: 15px;
      border-radius: 6px;
      margin-bottom: 20px;
      border-left: 4px solid #ff9800;
    }

    .settings {
      margin-bottom: 20px;
    }

    .settings label {
      display: block;
      margin-bottom: 5px;
      font-weight: 600;
      color: #555;
    }

    .settings input {
      width: 100%;
      padding: 10px;
      border: 2px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }

    .settings input:focus {
      outline: none;
      border-color: #4CAF50;
    }
  </style>
</head>
<body>
  <h1>üöÄ Non-blocking WASM CSV Parser Demo</h1>

  <div class="info">
    <strong>Purpose:</strong> This demo demonstrates the difference between blocking (main thread) and non-blocking (Web Worker + WASM) CSV parsing.
    The counter below should continue animating during non-blocking parsing, but will freeze during blocking parsing.
  </div>

  <div class="counter" id="counter">0</div>

  <div class="settings">
    <label for="rowCount">Number of rows to generate:</label>
    <input type="number" id="rowCount" value="100000" min="1000" max="1000000" step="1000">
  </div>

  <div class="container">
    <div class="panel">
      <h2>‚ö†Ô∏è Blocking (Main Thread)</h2>
      <button class="btn-blocking" id="btnBlocking">
        Parse on Main Thread
      </button>
      <div class="status idle" id="statusBlocking">
        Ready. Click button to parse CSV on main thread.
        <br><br>
        <strong>Warning:</strong> The counter will FREEZE during parsing!
      </div>
    </div>

    <div class="panel">
      <h2>‚úÖ Non-blocking (Worker + WASM)</h2>
      <button class="btn-nonblocking" id="btnNonBlocking">
        Parse in Worker with WASM
      </button>
      <div class="status idle" id="statusNonBlocking">
        Ready. Click button to parse CSV in Worker thread with WASM.
        <br><br>
        <strong>Note:</strong> The counter will CONTINUE animating during parsing!
      </div>
    </div>
  </div>

  <script type="module">
    import {
      parse,
      parseUint8ArrayStream,
      loadWASM
    } from '../dist/web-csv-toolbox.js';

    // Initialize WASM
    await loadWASM();

    // Counter animation
    let counter = 0;
    setInterval(() => {
      counter++;
      document.getElementById('counter').textContent = counter;
    }, 100);

    // Generate large CSV data
    function generateLargeCSV(rows) {
      const headers = 'id,name,email,age,city,country,occupation,salary';
      const sampleRow = (id) =>
        `${id},John Doe ${id},john.doe${id}@example.com,${20 + (id % 50)},Tokyo,Japan,Engineer,${50000 + (id % 50000)}`;

      const lines = [headers];
      for (let i = 1; i <= rows; i++) {
        lines.push(sampleRow(i));
      }
      return lines.join('\n');
    }

    // Main thread blocking parse
    async function parseBlocking() {
      const statusEl = document.getElementById('statusBlocking');
      const btn = document.getElementById('btnBlocking');
      const rowCount = parseInt(document.getElementById('rowCount').value);

      try {
        btn.disabled = true;
        statusEl.className = 'status working';
        statusEl.textContent = `Generating ${rowCount.toLocaleString()} rows of CSV data...`;

        // Small delay to let UI update
        await new Promise(resolve => setTimeout(resolve, 50));

        const csvData = generateLargeCSV(rowCount);
        const bytes = new TextEncoder().encode(csvData);

        statusEl.textContent = `Parsing ${(bytes.length / 1024 / 1024).toFixed(2)} MB of CSV data on MAIN THREAD...\n\nWATCH THE COUNTER - IT SHOULD FREEZE!`;

        // Small delay to let UI update
        await new Promise(resolve => setTimeout(resolve, 50));

        const startTime = performance.now();
        let recordCount = 0;

        // Parse on main thread (BLOCKING!)
        for await (const record of parseUint8ArrayStream(bytes)) {
          recordCount++;
        }

        const endTime = performance.now();
        const duration = ((endTime - startTime) / 1000).toFixed(2);

        statusEl.className = 'status done';
        statusEl.innerHTML = `
          <strong>‚úì Completed (Main Thread - BLOCKING)</strong><br><br>
          Records parsed: ${recordCount.toLocaleString()}<br>
          Time: ${duration}s<br>
          Speed: ${(recordCount / parseFloat(duration)).toFixed(0).toLocaleString()} records/sec<br>
          Data size: ${(bytes.length / 1024 / 1024).toFixed(2)} MB<br><br>
          <strong>Did you notice the counter froze?</strong>
        `;
      } catch (error) {
        statusEl.className = 'status error';
        statusEl.textContent = `Error: ${error.message}`;
      } finally {
        btn.disabled = false;
      }
    }

    // Worker non-blocking parse
    async function parseNonBlocking() {
      const statusEl = document.getElementById('statusNonBlocking');
      const btn = document.getElementById('btnNonBlocking');
      const rowCount = parseInt(document.getElementById('rowCount').value);

      try {
        btn.disabled = true;
        statusEl.className = 'status working';
        statusEl.textContent = `Generating ${rowCount.toLocaleString()} rows of CSV data...`;

        // Small delay to let UI update
        await new Promise(resolve => setTimeout(resolve, 50));

        const csvData = generateLargeCSV(rowCount);
        const bytes = new TextEncoder().encode(csvData);

        // Create a ReadableStream from the bytes
        const stream = new ReadableStream({
          start(controller) {
            controller.enqueue(bytes);
            controller.close();
          }
        });

        statusEl.textContent = `Parsing ${(bytes.length / 1024 / 1024).toFixed(2)} MB of CSV data in WORKER with WASM...\n\nWATCH THE COUNTER - IT SHOULD KEEP ANIMATING!`;

        const startTime = performance.now();
        let recordCount = 0;

        // Parse in worker with WASM (NON-BLOCKING!)
        for await (const record of parseUint8ArrayStream(stream, {
          engine: {
            worker: true,
            wasm: true
          }
        })) {
          recordCount++;

          // Update status every 10000 records
          if (recordCount % 10000 === 0) {
            statusEl.textContent = `Parsing in Worker with WASM...\n\nProcessed: ${recordCount.toLocaleString()} records\n\nWATCH THE COUNTER - IT SHOULD KEEP ANIMATING!`;
          }
        }

        const endTime = performance.now();
        const duration = ((endTime - startTime) / 1000).toFixed(2);

        statusEl.className = 'status done';
        statusEl.innerHTML = `
          <strong>‚úì Completed (Worker + WASM - NON-BLOCKING)</strong><br><br>
          Records parsed: ${recordCount.toLocaleString()}<br>
          Time: ${duration}s<br>
          Speed: ${(recordCount / parseFloat(duration)).toFixed(0).toLocaleString()} records/sec<br>
          Data size: ${(bytes.length / 1024 / 1024).toFixed(2)} MB<br><br>
          <strong>The counter kept animating, right?</strong>
        `;
      } catch (error) {
        statusEl.className = 'status error';
        statusEl.textContent = `Error: ${error.message}\n\n${error.stack}`;
      } finally {
        btn.disabled = false;
      }
    }

    // Add event listeners
    document.getElementById('btnBlocking').addEventListener('click', parseBlocking);
    document.getElementById('btnNonBlocking').addEventListener('click', parseNonBlocking);
  </script>
</body>
</html>
